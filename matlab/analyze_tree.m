
% extracts the analyzes the RANS-RRT* tree loaded by "load_tree.m"

%% load the tree and plot it

load_tree();

figure();
title('RANS-RRT* Tree generated by python script')
hold on;
for ii = 1:size(X,1)
    xPy = X(ii,:); 
    xPy = reshape(xPy, [n, N+1]);
    plot(xPy(1,:), xPy(2,:), 'b', 'LineWidth', 1);
end

%% Choose a node to go to from the figure

goal = [0.263694; -2.34915]; % replace this with a node from the plotted figure (use all 6 digits)
goal = [-0.739465; -1.63793];
%% Find trajectory to which this node belongs to

found_node = false;

for ii = 1:size(X,1)
    xPy = X(ii,:); 
    xPy = reshape(xPy, [n, N+1]);
    search_res = find(abs(xPy(1:2,:) - goal) <= 10^-4);
    if ~isempty(search_res)
        found_node = true;
        break
    end
end

if ~found_node
    disp('Node not found in tree. Update `goal` and try again')
    return
else
    goal_node = ii;
    disp('Node found in trajectory:')
    disp(goal_node)
end

%% find list of parents from root node to chosen goal node
at_root = false;
current_node = goal_node;
parent_list = [current_node];
while ~at_root
    parent_of_current_node = parent(current_node);
    parent_list = [parent_list, parent_of_current_node];
    current_node = parent_of_current_node;
    if current_node == 0
        break
    end
end

%% Get all the trajectories corresponding to this list of parent nodes
state_list = {};
ctrl_list = {};

i = 1;
while parent_list(i) ~= 0 % while not at root node
    node_idx = parent_list(i);
    node_states = X(node_idx, :);
    node_ctrls = U(node_idx, :);
    % save the states and controls
    state_list{i} = reshape(node_states, [n,N+1]);
    ctrl_list{i} = reshape(node_ctrls, [m,N]);
    i = i+1;
end
% trajectory now goes from goal to root. Flip it to go from root to goal
state_list = flip(state_list);
ctrl_list = flip(ctrl_list);

%% simulate each node trajectory on its own and plot them

opt_traj_sim_piecewise = state_list;

for ii = 1:length(state_list)
    for jj = 1:N
        xnow = opt_traj_sim_piecewise{ii}(:, jj);
        unow = ctrl_list{ii}(:, jj);
        opt_traj_sim_piecewise{ii}(:, jj+1) = uni_dyn(xnow, unow, dt);
    end 
end

figure()
hold on
title('Original tree (blue) and Piecewise MATLAB simulation (red)')
for ii = 1:length(state_list)
    plot(state_list{ii}(1,:), state_list{ii}(2,:), 'b', 'LineWidth', 3);
    plot(opt_traj_sim_piecewise{ii}(1,:), opt_traj_sim_piecewise{ii}(2,:), 'r', 'LineWidth', 1);
end

%% compare end state of traj i and start of traj i+1 (should be identical)

errors = {};
for ii = 1:length(state_list)-1
    end_of_ii = opt_traj_sim_piecewise{ii}(:,end);
    start_of_iip1 = opt_traj_sim_piecewise{ii+1}(:,1);
    errors{ii} = abs(start_of_iip1 - end_of_ii);
end

errors_list = cell2mat(errors);
figure()
plot(errors_list(1,:))
title('Switching piecewise trajs mismatch')
legend('State: x')
figure()
plot(errors_list(2,:))
title('Switching piecewise trajs mismatch')
legend('State: y')
figure()
plot(errors_list(3,:))
title('Switching piecewise trajs mismatch')
legend('State: theta')

%% start at root and use the controls to simulate the trajectory and plot


opt_traj_sim = state_list;

for ii = 1:length(state_list)
    for jj = 1:N
        xnow = opt_traj_sim{ii}(:, jj);
        unow = ctrl_list{ii}(:, jj);
        opt_traj_sim{ii}(:, jj+1) = uni_dyn(xnow, unow, dt);
    end 
    % set next starting state as current final state
    if ii < length(state_list)
        opt_traj_sim{ii+1}(:, 1) = opt_traj_sim{ii}(:, end);
    end
end

figure()
hold on
title('Original tree (blue) and FULL MATLAB simulation (red)')
for ii = 1:length(state_list)
    plot(state_list{ii}(1,:), state_list{ii}(2,:), 'b', 'LineWidth', 3);
    plot(opt_traj_sim{ii}(1,:), opt_traj_sim{ii}(2,:), 'r', 'LineWidth', 1);
end















